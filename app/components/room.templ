package components

import "strconv"
import "sort"
import "github.com/joaquinrovira/infiltra2-returns/app/util"
import "github.com/joaquinrovira/infiltra2-returns/app/model"
import "github.com/joaquinrovira/infiltra2-returns/app/routes"
import "github.com/joaquinrovira/infiltra2-returns/app/constants"

templ RoomFull(user string, room *model.Room) {
	@ArtDecoLayout() {
		<div class="contents" hx-ext="sse" sse-connect={ routes.RoomSSESpecific(room.Name()) }>
			<div id="boost-target" class="contents" hx-get={ routes.RoomSpecific(room.Name()) } hx-trigger="sse:RoomUpdate delay:1s">
				@Room(user, room)
			</div>
		</div>
	}
}

templ Room(user string, room *model.Room) {
	<div class="grow relative flex flex-col">
		if ShouldDisplayWord(room) {
			@RoomWord(user, room)
		} else {
			@RoomNoWord(user, room)
		}
	</div>
	if room.CountdownActive {
		@CountdownTimer(room)
	}
	@ReadyButton(user, room)
}

templ ReadyButton(user string, room *model.Room) {
	// TODO: 	Avoid errors when user presses multiple times.
	//			Replace with link to /room/:id/ready or /room/:id/not-ready
	<form class="contents" hx-boost="true" hx-target="#boost-target" action={ templ.SafeURL(routes.ReadySpecific(room.Name())) }>
		<div class="sticky bottom-0">
			if !UserReady(user, room) {
				<button
					type="submit"
					class="
						h-16 w-full transition-colors 
						hover:bg-green-300 hover:text-black/70 
						bg-green-500 text-white/90 
						font-bold text-2xl"
				>Listo</button>
			} else {
				<button
					type="submit"
					class="
						h-16 w-full transition-colors 
						hover:bg-amber-300 hover:text-black/70 
						bg-amber-500 text-white/90 
						font-bold text-2xl"
				>No listo</button>
			}
		</div>
	</form>
}

templ RoomNoWord(user string, room *model.Room) {
	<div class="grid p-3 gap-4 grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 w-full">
		for _, userData := range SortedUsers(user, room) {
			@UserCard(userData.Id, userData.State, user == userData.Id)
		}
	</div>
}

func Maybe2Grids(room *model.Room) string {
	if room.UserCount() < 4 {
		return ""
	}
	return "max-md:grid-rows-2"
}

templ RoomWord(user string, room *model.Room) {
	<div id="user-cards" class={ "py-4 px-2 gap-1 md:gap-4 grid grid-flow-col overflow-y-auto", Maybe2Grids(room) }>
		for _, userData := range SortedUsers(user, room) {
			@UserCardSmol(userData.Id, userData.State, user == userData.Id)
		}
	</div>
	// WORD RECEIVE BLOCK
	if HasSelectedWord(room) {
		<div class="flex flex-col grow p-8 justify-center items-center container mx-auto">
			<div class="text-center mb-6">
				<span class="break-words text-5xl md:text-8xl capitalize font-medium">
					if selectedUser, _ := room.SelectedUser(); user == selectedUser {
						üïµÔ∏è infiltrado
					} else {
						{ room.SelectedWordOrEmpty() }
					}
				</span>
			</div>
			<ol class="font-serif text-xl max-md:tracking-wide md:text-2xl list-decimal hyphens-auto [&>li]:mb-4 px-4 leading-6">
				if selectedUser, _ := room.SelectedUser(); user != selectedUser {
					for _, description := range (SelectedWord(room).Description) {
						<li>{ description }</li>
					}
				} else {
					<li>Eres el infiltrado! <i>Disimula...</i></li>
					<li>Te recomiendo que finjas leer esta descripci√≥n.</li>
					<li>Si ves que los demas entran a ver la definici√≥n en la RAE, tambi√©n deber√≠as aparentarlo.</li>
					<li>Persona introducida subrepticiamente en un grupo adversario, en territorio enemigo, etc.</li>
				}
			</ol>
			<a class="hover:*:underline font-semibold leading-6" href={ templ.SafeURL("https://dle.rae.es/" + UserWord(user, room)) } target="_blank" rel="noopener noreferrer">
				<span class="inline-flex items-center justify-center">
					<img
						class="h-16 w-16 md:h-20 md:w-20 object-scale-down"
						src="/_/img/logo-rae.png"
					/>
					<span class="w-16">Ver en la RAE</span>
				</span>
			</a>
		</div>
	}
}

templ UserCardSmol(user string, state model.UserRoomState, isUser bool) {
	<div class="flex flex-col text-center items-center">
		<div class={ "rounded-full p-1 bg-gradient-to-br", BoolString(state.Ready, "from-red-500 to-amber-400", "from-green-500 to-blue-500") }>
			<div class={ BoolString(state.Ready, "bg-amber-500/30", "bg-green-500/30"), "rounded-full flex justify-center h-12 w-12 md:h-16 md:w-16 lg:h-20 lg:w-20 xl:h-20 xl:w-20 transition-all box-border border-2 md:border-4 items-center " }>
				<img
					class="p-1 h-[inherit] w-[inherit] object-scale-down rounded-full"
					src={ "/_/img/user/user_" + strconv.Itoa(util.UserIdStringToInt(user)%11) + ".png" }
				/>
			</div>
		</div>
		<div class="contents mt-1 text-sm md:text-base">
			<div>{ util.UserName(user) }</div>
			if isUser {
				<div class="text-slate-500 text-xs md:text-sm">T√∫</div>
			}
		</div>
	</div>
}

templ CountdownTimer(room *model.Room) {
	<div class="fixed top-0 h-full w-full bg-black/70 text-white">
		<div class="h-dvh w-full flex justify-center items-center sticky top-0">
			<div id="countdown" class="text-9xl ">{ strconv.FormatFloat(constants.COUNTDOWN_TIME.Seconds(), 'f', -1, 32) }</div>
		</div>
	</div>
	@countdown(int(constants.COUNTDOWN_TIME.Seconds()), "countdown")
}

script countdown(seconds int, targetElementId string) {
	var countdownElement = document.getElementById(targetElementId);
	var countdownValue = Number(seconds);
	var countdown = setInterval(function() {
		countdownValue--;
		countdownElement.textContent = countdownValue;
		if (countdownValue <= 0) {
			clearInterval(countdown);
		}
	}, 1000);
}

templ UserCard(user string, state model.UserRoomState, isUser bool) {
	<div class="backdrop-brightness-75 rounded-2xl flex justify-center p-3 w-full h-24 items-center transition-colors">
		<img
			class="p-2 h-[inherit] object-scale-down rounded-full"
			src={ "/_/img/user/user_" + strconv.Itoa(util.UserIdStringToInt(user)%11) + ".png" }
		/>
		if isUser {
			<div class="ml-3 text- font-semibold">(You)</div>
		}
		<div class="ml-3 text-lg font-semibold">{ util.UserName(user) }</div>
		if state.Ready {
			<div class="ml-3 text-lg font-semibold text-green-700">Ready</div>
		} else {
			<div class="ml-3 text-lg font-semibold text-orange-700">Not Ready</div>
		}
	</div>
}

func BoolString(b bool, ok string, notOk string) string {
	if b {
		return ok
	} else {
		return notOk
	}
}

func UserReady(user string, room *model.Room) bool {
	state, exists := room.User(user)
	return exists && state.Ready
}

func ShouldDisplayWord(room *model.Room) bool {
	_, userSelected := room.SelectedUser()
	_, wordSelected := room.SelectedWord()
	return userSelected && wordSelected
}

// func SortedUsers(user string, room *model.Room) []UserData {
// 	return FakeSortedUsers(user, room, 30)
// }

// func FakeSortedUsers(user string, room *model.Room, n int) []UserData {
// 	users := _SortedUsers(user, room)

// 	if len(users) > 0 {
// 		for len(users) < n {
// 			users = append(users, users[0])
// 		}
// 	}

// 	return users
// }

func SortedUsers(user string, room *model.Room) []UserData {
	userStates := room.Users()
	ids := make([]string, 0, len(userStates))
	for k := range userStates {
		ids = append(ids, k)
	}
	sort.Slice(ids, func(i, j int) bool {
		if ids[i] == user {
			return true // Move specific ID to the front
		}
		if ids[j] == user {
			return false // Move specific ID to the front
		}
		return ids[i] < ids[j] // Sort the rest
	})

	users := make([]UserData, 0, len(userStates))
	for _, id := range ids {
		users = append(users, UserData{
			Id:    id,
			State: userStates[id],
		})
	}
	return users
}

type UserData struct {
	Id    string
	State model.UserRoomState
}

func SelectedWord(room *model.Room) *model.Word {
	word, exists := room.SelectedWord()
	if !exists {
		return nil
	} else {
		return &word
	}
}
func HasSelectedWord(room *model.Room) bool {
	_, exists := room.SelectedWord()
	return exists
}

func UserWord(user string, room *model.Room) string {
	if selectedUser, _ := room.SelectedUser(); user == selectedUser {
		return "infiltrado"
	} else {
		return room.SelectedWordOrEmpty()
	}
}
